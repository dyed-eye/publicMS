# -*- coding: utf-8 -*-
"""0 Введение.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hX6NcJCUxcSOWTqM4E9MP3i5iMuLUxXB

В данном документе представлены коды из 0 лекции про математический аппарат.

---



0.5 Системы координат (мат)
Задача 0.5.1 Необходимо написать программу, которая бы выдавала положение материальной точки в различных системах координат: декартовой, цилиндрической, сферической.
Например, на вход программы передаются координаты в декартовой системе, а программа выдает в цилиндрической и сферической системах координат. Визуализация?

---

0.6 Векторы. Скалярное произведение (мат)
Задача 0.6.1 Написать программу, которая вычисляет угол между двумя    произвольными векторами, заданными в декартовой системе координат.
На вход передаются по три компоненты каждого из векторов, а на выходе мы получаем угол между ними в радианах.

---

0.7 Векторное произведение векторов
Задача 0.7.1 Написать программу, которая вычисляет объем параллелепипеда, натянутого на три некомпланарных вектора.
На вход программы передаются три тройки чисел, описывающих три некомпланарных вектора. На выходе получаем объем или сообщение о том, что данные вектора компланарны.

---

0.8 Дифференцирование. Производная (мат)
Задача 1.8.1 Написать программу, которая бы численно находила первую и вторую производные функции, заданной аналитически, а также могла бы построить график первой и второй численных производных на заданном интервале.
На вход программы подаются функция и интервал, на выходе получаем два графика. В качестве проверки можно запрашивать значения первой и второй производных в произвольных точках.

---

0.9 Интегрирование. Первообразная (мат)
Задача 0.9.1 Написать программу для одномерного интегрирования функций при помощи самых простых схем: прямоугольниками и трапециями.
На вход программы подаются функция и интервал, а на выходе получаем значение определенного интеграла.

---

0.10 Обработка данных физического эксперимента.
Задача 0.10.1 Написать программу, которая по заданной выборке находила бы дисперсию и математическое ожидание.
На вход подается таблица определенного формата с данными, а на выходе получаем статистическую информацию о данной выборке.
"""

import matplotlib.pyplot as plt
import numpy as np

plt.rcParams.update({"font.family": "serif", "font.cursive": ["Comic Neue", "Comic Sans MS"]})
plt.rcParams['figure.dpi'] = 600
# @title Системы координат

# @markdown Выберите декартовы координаты материальной точки
x = "2"  # @param {type:"string"}
y = "3"  # @param {type:"string"}
z = "4"  # @param {type:"string"}
x = float(x)
y = float(y)
z = float(z)


def cartesian_to_cylindrical(x, y, z):
    r = np.sqrt(x ** 2 + y ** 2)
    phi = np.arctan(y / x)
    return r, phi, z


def cartesian_to_spherical(x, y, z):
    r = np.sqrt(x ** 2 + y ** 2 + z ** 2)
    phi = np.arctan(y / x)
    theta = np.arccos(z / r)
    return r, theta, phi


X = x
Y = y
if x == 0:
    x = 1e-30
if y == 0:
    y = 1e-30
if X == 0 and Y == 0:
    print('Ошибка! Выберите ненулевые значения x и y')
else:
    r_cylindrical, theta_cylindrical, z_cylindrical = cartesian_to_cylindrical(x, y, z)
    r_spherical, theta_spherical, phi_spherical = cartesian_to_spherical(x, y, z)
    m = r_spherical
    phi_cylindrical = theta_cylindrical
    phi_sph = phi_spherical
    if phi_cylindrical < 0:
        phi_cylindrical += np.pi
        phi_sph += np.pi

    print(f"Декартовы координаты: ({X}, {Y}, {z})")
    print(f"Цилиндрические координаты: ({r_cylindrical:.5f}, {phi_cylindrical:.5f}, {z_cylindrical:.5f})")
    print(f"Сферические координаты: ({r_spherical:.5f}, {theta_spherical:.5f}, {phi_sph:.5f})")

    fig = plt.figure(figsize=plt.figaspect(0.3))
    ax = fig.add_subplot(1, 3, 1, projection="3d")
    ax.scatter(x, y, z, c='b')
    ax.quiver(0, 0, 0, x, y, z, color='b')
    ax.plot([x, x], [0, y], '--', c='b', alpha=1)
    ax.plot([0, x], [y, y], '--', c='b', alpha=1)
    ax.plot([x, x], [y, y], [0, z], '--', c='b', alpha=1)
    ax.quiver(0, 0, 0, 1.1 * m, 0, 0, color='k')
    ax.quiver(0, 0, 0, 0, 1.1 * m, 0, color='k')
    ax.quiver(0, 0, 0, 0, 0, 1.1 * m, color='k')
    ax.plot([-abs(1.1 * m), abs(1.1 * m)], [0, 0], [0, 0], c='k')
    ax.plot([0, 0], [-abs(1.1 * m), abs(1.1 * m)], [0, 0], c='k')
    ax.plot([0, 0], [0, 0], [-abs(1.1 * m), abs(1.1 * m)], c='k')

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_xlim3d(-m, m)
    ax.set_ylim3d(-m, m)
    ax.set_zlim3d(-m, m)
    ax.grid(False)
    ax.azim = -80
    ax.elev = 30
    ax.set_title('Декартова система координат')

    ax = fig.add_subplot(1, 3, 2, projection="3d")
    ax.scatter(x, y, z, c='g')
    ax.quiver(0, 0, 0, x, y, z, color='g')
    ax.plot([0, x], [0, y], '-', c='g', alpha=1)
    ax.plot([x, x], [y, y], [z, 0], '-', c='g', alpha=1)
    ax.plot([-abs(1.1 * m), abs(1.1 * m)], [0, 0], [0, 0], c='k')
    ax.plot([0, 0], [-abs(1.1 * m), abs(1.1 * m)], [0, 0], c='k')
    ax.plot([0, 0], [0, 0], [-abs(1.1 * m), abs(1.1 * m)], c='k')
    ax.quiver(0, 0, 0, 1.1 * m, 0, 0, color='k')
    ax.quiver(0, 0, 0, 0, 1.1 * m, 0, color='k')
    ax.quiver(0, 0, 0, 0, 0, 1.1 * m, color='k')

    xx = np.array([x, 0])
    yy = np.array([y, 0])
    zz = np.array([0, 0])

    if theta_cylindrical < 0:
        angle = 2 * np.pi + theta_cylindrical
    else:
        angle = theta_cylindrical
        if x < 0 and y < 0:
            angle += np.pi
    if x < 0 and y > 0:
        angle -= np.pi

    u = np.linspace(0, angle, 30)
    v = np.linspace(0, np.pi / 2, 30)
    U, V = np.meshgrid(u, v)
    X = xx[1] + np.sin(V) * np.cos(U) * (xx[0] - xx[1]) + np.sin(V) * np.sin(U) * (yy[0] - yy[1])
    Y = yy[1] + np.sin(V) * np.cos(U) * (yy[0] - yy[1]) + np.sin(V) * np.sin(U) * (xx[1] - xx[0])
    Z = zz[1] + np.cos(V) * (zz[0] - zz[1])

    ax.plot_surface(X, Y, Z, color='g', alpha=0.6)

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_xlim3d(-m, m)
    ax.set_ylim3d(-m, m)
    ax.set_zlim3d(-m, m)
    ax.grid(False)
    ax.azim = -80

    ax.elev = 30
    ax.set_title('Цилиндрическая система координат')

    ax = fig.add_subplot(1, 3, 3, projection="3d")
    ax.scatter(x, y, z, c='r')
    ax.quiver(0, 0, 0, x, y, z, color='r')
    ax.plot([0, x], [0, y], '--', c='r', alpha=0.2)
    ax.plot([x, x], [y, y], [z, 0], '--', c='r', alpha=0.2)
    ax.plot([-abs(1.1 * m), abs(1.1 * m)], [0, 0], [0, 0], c='k')
    ax.plot([0, 0], [-abs(1.1 * m), abs(1.1 * m)], [0, 0], c='k')
    ax.plot([0, 0], [0, 0], [-abs(1.1 * m), abs(1.1 * m)], c='k')
    ax.quiver(0, 0, 0, 1.1 * m, 0, 0, color='k')
    ax.quiver(0, 0, 0, 0, 1.1 * m, 0, color='k')
    ax.quiver(0, 0, 0, 0, 0, 1.1 * m, color='k')

    xx = np.array([x, 0])
    yy = np.array([y, 0])
    zz = np.array([0, 0])

    if theta_cylindrical < 0:
        angle = 2 * np.pi + theta_cylindrical
    else:
        angle = theta_cylindrical
        if x < 0 and y < 0:
            angle += np.pi
    if x < 0 and y > 0:
        angle -= np.pi
    if y == 0 and x < 0:
        angle = np.pi
    phi = angle
    u = np.linspace(0, angle, 30)
    v = np.linspace(0, np.pi / 2, 30)
    U, V = np.meshgrid(u, v)
    X = xx[1] + np.sin(V) * np.cos(U) * (xx[0] - xx[1]) + np.sin(V) * np.sin(U) * (yy[0] - yy[1])
    Y = yy[1] + np.sin(V) * np.cos(U) * (yy[0] - yy[1]) + np.sin(V) * np.sin(U) * (xx[1] - xx[0])
    Z = zz[1] + np.cos(V) * (zz[0] - zz[1])

    ax.plot_surface(X, Y, Z, color='r', alpha=0.6)

    xx = np.array([0, 0])
    yy = np.array([0, 0])
    zz = np.array([r_spherical, 0])

    angle = theta_spherical

    u = np.linspace(0, angle, 30)
    v = np.linspace(0, np.pi / 2, 30)
    U, V = np.meshgrid(u, v)
    Y = yy[1] + np.sin(V) * np.cos(U) * (yy[0] - yy[1]) + np.sin(V) * np.sin(U) * (zz[0] - zz[1])
    Z = zz[1] + np.sin(V) * np.cos(U) * (zz[0] - zz[1]) + np.sin(V) * np.sin(U) * (yy[1] - yy[0])
    X = xx[1] + np.cos(V) * (xx[0] - xx[1])

    phi += 1.5 * np.pi

    cos_theta = np.cos(phi)
    sin_theta = np.sin(phi)
    rotation_matrix = np.array([[cos_theta, -sin_theta, 0],
                                [sin_theta, cos_theta, 0],
                                [0, 0, 1]])

    points = np.vstack((X.flatten(), Y.flatten(), Z.flatten()))
    points_rotated = rotation_matrix.dot(points)

    X_rotated = points_rotated[0].reshape(X.shape)
    Y_rotated = points_rotated[1].reshape(Y.shape)
    Z_rotated = points_rotated[2].reshape(Z.shape)

    ax.plot_surface(X_rotated, Y_rotated, Z_rotated, color='r', alpha=0.6)

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.set_xlim3d(-m, m)
    ax.set_ylim3d(-m, m)
    ax.set_zlim3d(-m, m)
    ax.grid(False)
    ax.azim = -80

    ax.elev = 30
    ax.set_title('Сферическая система координат')
    fig.suptitle('Разные способы задания координат материальной точки')
    fig.tight_layout()
    plt.show()

import math
import matplotlib.pyplot as plt
import numpy as np
import warnings
warnings.filterwarnings("ignore")
plt.rcParams.update({"font.family": "serif", "font.cursive": ["Comic Neue", "Comic Sans MS"]})
plt.rcParams['figure.dpi'] = 150
#@title Векторы. Скалярное произведение
import numpy as np
from matplotlib import pyplot as plt

#@markdown Выберите координаты первого вектора
x1 = "1" # @param {type:"string"}
y1 = "2" # @param {type:"string"}
z1 = "3" # @param {type:"string"}
x1 = float(x1)
y1 = float(y1)
z1 = float(z1)


#@markdown Выберите координаты второго вектора
x2 = "3" # @param {type:"string"}
y2 = "2" # @param {type:"string"}
z2 = "1" # @param {type:"string"}
x2 = float(x2)
y2 = float(y2)
z2 = float(z2)

def angle(v1, v2):
    angle = np.arccos(np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)))
    if math.isnan(angle):
        angle = np.pi
    if angle <= np.pi:
        return angle
    else:
        return 2 * np.pi - angle


vec1 = [x1, y1, z1]
vec2 = [x2, y2, z2]

fig = plt.figure(figsize=(8,5))
ax = fig.add_subplot(1, 1, 1, projection="3d")
m = max(vec1[0] ** 2 + vec1[1] ** 2 + vec1[2] ** 2, vec2[0] ** 2 + vec2[1] ** 2 + vec2[2] ** 2) ** 0.5
ax.quiver(0, 0, 0, 1.1 * m, 0, 0, color='k')
ax.quiver(0, 0, 0, 0, 1.1 * m, 0, color='k')
ax.quiver(0, 0, 0, 0, 0, 1.1 * m, color='k')
ax.plot([-abs(1.1 * m), abs(1.1 * m)], [0, 0], [0, 0], c='k')
ax.plot([0, 0], [-abs(1.1 * m), abs(1.1 * m)], [0, 0], c='k')
ax.plot([0, 0], [0, 0], [-abs(1.1 * m), abs(1.1 * m)], c='k')
ax.quiver(0, 0, 0, vec1[0], vec1[1], vec1[2], color='b')
ax.quiver(0, 0, 0, vec2[0], vec2[1], vec2[2], color='r')
if vec1 == vec2 or (x1 == 0 and y1 == 0 and z1 == 0 or x2 == 0 and y2 == 0 and z2 == 0):
    print(f"Полученный угол равен: {0} радиан")
else:
    print(f"Полученный угол равен: {angle(vec1, vec2):.5f} радиан")
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_xlim3d(-m, m)
ax.set_ylim3d(-m, m)
ax.set_zlim3d(-m, m)
ax.text(vec1[0], vec1[1], vec1[2], '1', color='blue')
ax.text(vec2[0], vec2[1], vec2[2], '2', color='red')
plt.show()

import math
import matplotlib.pyplot as plt
import numpy as np
import warnings
warnings.filterwarnings("ignore")
plt.rcParams.update({"font.family": "serif", "font.cursive": ["Comic Neue", "Comic Sans MS"]})
plt.rcParams['figure.dpi'] = 150
#@title Векторы. Векторное произведение
import numpy as np
from matplotlib import pyplot as plt

#@markdown Выберите координаты первого вектора
x1 = "1" # @param {type:"string"}
y1 = "0" # @param {type:"string"}
z1 = "0" # @param {type:"string"}
x1 = float(x1)
y1 = float(y1)
z1 = float(z1)


#@markdown Выберите координаты второго вектора
x2 = "0" # @param {type:"string"}
y2 = "1" # @param {type:"string"}
z2 = "2" # @param {type:"string"}
x2 = float(x2)
y2 = float(y2)
z2 = float(z2)

#@markdown Выберите координаты третьего вектора
x3 = "1" # @param {type:"string"}
y3 = "2" # @param {type:"string"}
z3 = "1" # @param {type:"string"}
x3 = float(x3)
y3 = float(y3)
z3 = float(z3)

import numpy as np
from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection
import matplotlib.pyplot as plt


def volume(a, b, c):
    matrix = np.array([a, b, c])
    if np.linalg.det(matrix) == 0:
        return "Заданные вектора компланарны"
    else:
        return abs(np.linalg.det(matrix))


#    X  Y  Z
a = [x1, y1, z1]
b = [x2, y2, z2]
c = [x3, y3, z3]
flag = False
V = volume(a, b, c)
if type(V) == str:
    print(V)
else:
    print(f"Объём параллелепипеда: {V:.5f}")
    flag = True

if flag:
    fig = plt.figure(figsize=(5,8))
    ax = fig.add_subplot(111, projection='3d')

    origin = [0, 0, 0]
    ax.quiver(*origin, *a, color='r')
    ax.quiver(*origin, *b, color='g')
    ax.quiver(*origin, *c, color='b')

    x = [0, b[0], a[0], a[0] + b[0], c[0], b[0] + c[0], a[0] + c[0], a[0] + b[0] + c[0]]
    y = [0, b[1], a[1], a[1] + b[1], c[1], b[1] + c[1], a[1] + c[1], a[1] + b[1] + c[1]]
    z = [0, b[2], a[2], a[2] + b[2], c[2], b[2] + c[2], a[2] + c[2], a[2] + b[2] + c[2]]

    vertices = [[0, 1, 3, 2], [1, 3, 7, 5], [0, 1, 5, 4], [4, 5, 7, 6], [0, 2, 6, 4]]

    tupleList = list(zip(x, y, z))

    poly3d = [[tupleList[vertices[ix][iy]] for iy in range(len(vertices[0]))] for ix in range(len(vertices))]
    ax.scatter(x, y, z, c='k')
    ax.add_collection3d(Poly3DCollection(poly3d, edgecolors='k', facecolors='w', linewidths=1, alpha=0.5))
    ax.set_xlim(1.8*min(a[0], b[0], c[0]), 1.8*max(a[0], b[0], c[0]))
    ax.set_ylim(1.8*min(a[1],b[1],c[1]), 1.8*max(a[1], b[1], c[1]))
    ax.set_zlim(1.8*min(a[2],b[2],c[2]), 1.8*max(a[2],b[2],c[2]))
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    # ax.set_aspect('equal', adjustable='box')
    plt.show()

#@title Численное дифференцирование

#@markdown https://ru.wikipedia.org/wiki/Коэффициенты_формул_численного_дифференцирования

from numpy import *
import matplotlib.pyplot as plt
from bisect import bisect_left
plt.rcParams['figure.dpi'] = 150
flag = True
def take_closest(myList, myNumber):
    pos = bisect_left(myList, myNumber)
    if pos == 0:
        return myList[0]
    if pos == len(myList):
        return myList[-1]
    before = myList[pos - 1]
    after = myList[pos]
    if after - myNumber < myNumber - before:
        return after
    else:
        return before
def f(x):
    return eval(function)


#@markdown Введите функцию

function = "ln(x)" # @param {type:"string"}
function = function.replace('^','*').replace('ln','log')

#@markdown Введите начальную точку исследуемого отрезка
xi = "1" # @param {type:"string"}
#@markdown Введите конечную точку исследуемого отрезка
xf = "exp(1)" # @param {type:"string"}
xi = eval(xi)
xf = eval(xf)
#@markdown Будет ли проверка производных в определенной точке?
check = "\u0414\u0430" # @param ["\u0414\u0430", "\u041D\u0435\u0442"]
if check == "\u0414\u0430":
  check = True
else:
  check = False


if xi == xf:
  print("Ошибка! Введите разные значения границ отрезка")
  flag = False

if flag:
  if xi > xf:
    print("Начальная и конечная точки поменялись местами")
    xi, xf = xf, xi
  if check:
    #@markdown Если да, то в какой точке из исследуемого интервала?
    check_x = "2" # @param {type:"string"}
    check_x = eval(check_x)
    x = linspace(xi, xf, 100000)
    if check_x < x[2] or check_x > x[-2]:
      print("Ошибка, выбранная точка должна быть в отрезке")
      flag = False

if flag:
  n = 100000
  x = linspace(xi, xf, n)

  y = zeros(n)
  for i in range(len(y)):
      y[i] = f(x[i])
  dydx = gradient(y, x)
  d2ydx2 = gradient(dydx, x)

  fig, ax = plt.subplots(figsize=(8,5))
  ax.plot(x, y, label='f(x)', c='b')
  ax.plot(x[1:-1], dydx[1:-1], label="f '(x)", c='g')
  ax.plot(x[2:-2], d2ydx2[2:-2], label="f ''(x)", c='r')

  if check:
      index = where(x == take_closest(x, check_x))[0][0]
      print(f"Значение первой производной в выбранной точке: {dydx[index]:.4f}\n"
            f"Значение второй производной в выбранной точке: {d2ydx2[index]:.4f}")
      ax.scatter(x[index], y[index], c='b')
      ax.scatter(x[index], dydx[index], c='g')
      ax.scatter(x[index], d2ydx2[index], c='r')


  ax.set_xlabel('X',fontsize=10)
  ax.set_ylabel('Y',fontsize=10)
  ax.legend(loc='lower right')
  plt.grid(True)

  plt.show()

#@title Численное интегрирование. Первообразная

from numpy import *
import matplotlib.pyplot as plt
plt.rcParams['figure.dpi'] = 150

#@markdown Введите функцию

function = "sin(x)" # @param {type:"string"}
function = function.replace('^','*').replace('log','ln')
#@markdown Введите исследуемый отрезок [$a$; $b$]
a = "1" # @param {type:"string"}
b = "2" # @param {type:"string"}
#@markdown Введите желаемое количество разбиений отрезка:
n = 3 # @param {type:"integer"}
n += 1
a, b = float(a), float(b)
def f(x):
    return eval(function)

X = linspace(a, b, int(1e5))
Y = []
for x in X:
    Y.append(f(x))
plt.figure(figsize=(8,4))
plt.plot(X, Y, c='b')
plt.plot([X[0], X[-1]], [0, 0], [X[0], X[0]],[Y[0], 0], [X[-1], X[-1]], [Y[-1], 0], c='r')

Xn = linspace(a, b, n)
plt.plot([X[0], X[-1]], [0, 0], [X[0], X[0]],[Y[0], 0], [X[-1], X[-1]], [Y[-1], 0], c='r')
plt.plot(X, Y, c='b')
plt.scatter(Xn, zeros(n), c='g')
step_x = zeros(n-1)
step_y = zeros(n-1)
for i, xn in enumerate(Xn):
    if i + 1 != n:
        xx = (Xn[i] + Xn[i+1])/2
        step_x[i] = xx
        step_y[i] = f(xx)
plt.plot([X[0], X[-1]], [0, 0], [X[0], X[0]],[Y[0], 0], [X[-1], X[-1]], [Y[-1], 0], c='r')
plt.plot(X, Y, c='b')
plt.scatter(Xn, zeros(n), c='g')
plt.scatter(step_x, step_y, c='y')
for i in range(n-1):
    plt.plot([Xn[i], Xn[i+1]], [step_y[i], step_y[i]], c='k')
    plt.plot([Xn[i], Xn[i]], [step_y[i], 0], c='k')
    plt.plot([Xn[i+1], Xn[i+1]], [step_y[i], 0], c='k')
I = 0
for i in range(len(step_x)):
    if i != n-2:
        I += (step_x[i+1]-step_x[i]) * step_y[i]
    else:
        I += (step_x[i]-step_x[i-1])*step_y[i]
print(f"Полученное значение методом средних прямоугольников: {I:.6f}")
plt.grid(True)
plt.title('Метод средних прямоугольников')
plt.show()

plt.figure(figsize=(8,4))
plt.plot([X[0], X[-1]], [0, 0], [X[0], X[0]],[Y[0], 0], [X[-1], X[-1]], [Y[-1], 0], c='r')
plt.plot(X, Y, c='b')
plt.scatter(Xn, zeros(n), c='g')
step_x = zeros(n-1).tolist()
step_y = zeros(n-1).tolist()
for i, xn in enumerate(Xn):
    if i != n-1:
        xx = Xn[i]
        step_x[i] = xx
        step_y[i] = f(xx)
    else:
        xx = Xn[-1]
        step_x.append(float(xx))
        step_y.append(float(f(xx)))

plt.plot([X[0], X[-1]], [0, 0], [X[0], X[0]],[Y[0], 0], [X[-1], X[-1]], [Y[-1], 0], c='r')
plt.plot(X, Y, c='b')
plt.scatter(Xn, zeros(n), c='g')
plt.scatter(step_x, step_y, c='y')
for i in range(n-1):
    if i != n-2:
        plt.plot([Xn[i], Xn[i+1]], [step_y[i], step_y[i+1]], c='k')
        plt.plot([Xn[i], Xn[i]], [step_y[i], 0], c='k')
        plt.plot([Xn[i+1], Xn[i+1]], [step_y[i+1], 0], c='k')
    else:
        plt.plot([Xn[-1], Xn[-1]], [step_y[-1], 0], c='k')
        plt.plot([Xn[-2], Xn[-1]], [step_y[i], step_y[-1]], c='k')
I = 0
for i in range(len(step_x)):
    if i < len(step_x)-1:
        I += (step_y[i]+step_y[i+1])/2 * (step_x[i+1] - step_x[i])
print(f"Полученное значение методом трапеций: {I:.6f}")
plt.grid(True)
plt.title("Метод трапеций")
plt.show()

#@title Обработка данных физического эксперимента
#@markdown 0.10 Обработка данных физического эксперимента.Задача 0.10.1 Написать программу, которая по заданной выборке находила бы дисперсию и математическое ожидание. На вход подается таблица определенного формата с данными, а на выходе получаем статистическую информацию о данной выборке.